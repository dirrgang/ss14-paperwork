#!/usr/bin/env python3
"""Generate doc-printer.ftl from source .paper documents."""

from __future__ import annotations

import argparse
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Tuple


class PaperParseError(RuntimeError):
    """Raised when a .paper document cannot be processed."""


def normalise_component(component: str) -> str:
    """Produce a filesystem/path-safe slug component."""
    cleaned = component.strip().lower().replace(" ", "-")
    cleaned = re.sub(r"[^a-z0-9-]+", "-", cleaned)
    cleaned = re.sub(r"-+", "-", cleaned).strip("-")
    return cleaned


@dataclass(slots=True)
class PaperDocument:
    path: Path
    categories: Tuple[str, ...]
    slug: str
    body_lines: List[str]

    @property
    def category_label(self) -> str:
        if not self.categories:
            return "uncategorized"
        return " / ".join(self.categories)

    @property
    def fluent_key(self) -> str:
        parts = [normalise_component(part) for part in (*self.categories, self.slug)]
        filtered = [part for part in parts if part]
        suffix = "-".join(filtered) if filtered else normalise_component(self.slug) or "paper"
        return f"doc-text-printer-{suffix}"


def list_document_paths(root: Path) -> List[Path]:
    paths: List[Path] = []
    for path in sorted(root.rglob("*.paper")):
        if should_skip(path, root):
            continue
        paths.append(path)
    return paths


def should_skip(path: Path, root: Path) -> bool:
    try:
        relative_parts = path.relative_to(root).parts
    except ValueError:
        return True
    return any(part.startswith("_") for part in relative_parts)


def discover_documents(root: Path) -> List[PaperDocument]:
    documents: List[PaperDocument] = []
    for path in list_document_paths(root):
        documents.append(parse_document(path, root))
    if not documents:
        raise PaperParseError(f"No .paper documents found under {root}")
    return documents


def parse_document(path: Path, root: Path) -> PaperDocument:
    try:
        raw_text = path.read_text(encoding="utf-8")
    except FileNotFoundError as exc:
        raise PaperParseError(f"Missing document: {path}") from exc

    if not raw_text.strip():
        raise PaperParseError(f"Document {path} is empty")

    normalised = raw_text.replace("\r\n", "\n").replace("\r", "\n")
    body_lines = normalised.split("\n")

    categories = tuple(path.relative_to(root).parent.parts)
    slug = path.stem

    return PaperDocument(path=path, categories=categories, slug=slug, body_lines=body_lines)


def render_ftl(documents: Iterable[PaperDocument]) -> str:
    docs = sorted(documents, key=lambda doc: (doc.categories, doc.slug))

    lines: List[str] = []
    lines.append("# Auto-generated by tools/render_ftl.py. Do not edit manually.")
    lines.append("# Source docs: docs/*.paper")

    current_category: Tuple[str, ...] | None = None
    for doc in docs:
        if doc.categories != current_category:
            lines.append("")
            lines.append(f"# {doc.category_label}")
            current_category = doc.categories

        lines.append("")
        lines.append(f"# slug: {doc.slug}")
        lines.append(f"{doc.fluent_key} =")
        if doc.body_lines:
            for raw_line in doc.body_lines:
                lines.append(f"    {raw_line}")
        else:
            lines.append("    ")
    lines.append("")
    return "\n".join(lines)


def write_output(content: str, destination: Path) -> bool:
    destination.parent.mkdir(parents=True, exist_ok=True)
    new_text = content + "\n"
    if destination.exists():
        current_text = destination.read_text(encoding="utf-8")
        if current_text == new_text:
            return False
    destination.write_text(new_text, encoding="utf-8")
    return True


def build_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--docs-dir",
        type=Path,
        default=Path(__file__).resolve().parents[1] / "docs",
        help="Path to the directory containing .paper documents",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path(__file__).resolve().parents[1] / "dist" / "doc-printer.ftl",
        help="Destination path for the generated Fluent file",
    )
    return parser


def main(argv: List[str] | None = None) -> int:
    parser = build_arg_parser()
    args = parser.parse_args(argv)

    try:
        documents = discover_documents(args.docs_dir)
        rendered = render_ftl(documents)
        changed = write_output(rendered, args.output)
        status = "Updated" if changed else "Up to date"
        print(f"{status} {args.output} from {len(documents)} document(s).")
        return 0
    except PaperParseError as exc:
        parser.error(str(exc))
        return 2


if __name__ == "__main__":
    raise SystemExit(main())